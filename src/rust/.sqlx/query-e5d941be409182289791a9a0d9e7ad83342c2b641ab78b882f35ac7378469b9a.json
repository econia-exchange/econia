{
  "db_name": "PostgreSQL",
  "query": "INSERT INTO aggregator.enumerated_volume (volume_as_base, volume_as_quote, \"address\", module, struct, generic_asset_name, last_indexed_txn)\nWITH base_volumes AS (\n    SELECT\n        size_to_base_indivisible_subunits(markets.market_id, SUM(\"size\")) AS volume_as_base,\n        base_account_address AS \"address\",\n        base_module_name AS module,\n        base_struct_name AS struct,\n        base_name_generic AS generic_asset_name\n    FROM fill_events, api.markets\n    WHERE emit_address = maker_address\n    AND markets.market_id = fill_events.market_id\n    AND fill_events.txn_version > COALESCE((\n        SELECT last_indexed_txn\n        FROM aggregator.enumerated_volume\n        WHERE (\n            markets.base_account_address = enumerated_volume.\"address\"\n            AND markets.base_module_name = enumerated_volume.module\n            AND markets.base_struct_name = enumerated_volume.struct\n            AND enumerated_volume.generic_asset_name = ''\n        )\n        OR (\n            enumerated_volume.\"address\" = ''\n            AND enumerated_volume.module = ''\n            AND enumerated_volume.struct = ''\n            AND enumerated_volume.generic_asset_name = markets.base_name_generic\n        )\n    ), 0)\n    GROUP BY\n        markets.market_id,\n        base_account_address,\n        base_module_name,\n        base_struct_name,\n        base_name_generic\n),\nquote_volumes AS (\n    SELECT\n        SUM(size_and_price_to_quote_indivisible_subunits(markets.market_id, \"size\", price)) AS volume_as_quote,\n        quote_account_address AS \"address\",\n        quote_module_name AS module,\n        quote_struct_name AS struct\n    FROM fill_events, api.markets\n    WHERE emit_address = maker_address\n    AND fill_events.txn_version > COALESCE((\n        SELECT last_indexed_txn\n        FROM aggregator.enumerated_volume\n        WHERE\n            markets.quote_account_address = enumerated_volume.\"address\"\n            AND markets.quote_module_name = enumerated_volume.module\n            AND markets.quote_struct_name = enumerated_volume.struct\n    ), 0)\n    AND markets.market_id = fill_events.market_id\n    GROUP BY\n        markets.market_id,\n        quote_account_address,\n        quote_module_name,\n        quote_struct_name\n),\nlatest AS (\n    SELECT\n        SUM(volume_as_base) AS volume_as_base,\n        SUM(volume_as_quote) AS volume_as_quote,\n        COALESCE(b.\"address\", q.\"address\") AS \"address\",\n        COALESCE(b.module, q.module) AS module,\n        COALESCE(b.struct, q.struct) AS struct,\n        b.generic_asset_name\n    FROM base_volumes b\n    FULL JOIN quote_volumes q\n    ON b.\"address\" = q.\"address\"\n    AND b.module = q.module\n    AND b.struct = q.struct\n    GROUP BY\n        b.\"address\",\n        b.module,\n        b.struct,\n        b.generic_asset_name,\n        q.\"address\",\n        q.module,\n        q.struct\n)\nSELECT\n    a.volume_as_base + COALESCE(b.volume_as_base,0),\n    a.volume_as_quote + COALESCE(b.volume_as_quote,0),\n    COALESCE(a.\"address\", ''), COALESCE(a.module, ''), COALESCE(a.struct, ''),\n    COALESCE(a.generic_asset_name, ''),\n    (SELECT txn_version FROM fill_events ORDER BY txn_version DESC LIMIT 1)\nFROM latest a\nLEFT JOIN\naggregator.enumerated_volume b\nON (b.\"address\" = a.\"address\"\nAND b.module = a.module\nAND b.struct = a.struct\nAND a.generic_asset_name IS NULL)\nOR (a.\"address\" IS NULL\nAND a.module IS NULL\nAND a.struct IS NULL\nAND a.generic_asset_name = b.generic_asset_name)\nON CONFLICT ON CONSTRAINT enumerated_volume_pkey DO\nUPDATE SET\n    volume_as_base = EXCLUDED.volume_as_base,\n    volume_as_quote = EXCLUDED.volume_as_quote,\n    last_indexed_txn = EXCLUDED.last_indexed_txn;\n",
  "describe": {
    "columns": [],
    "parameters": {
      "Left": []
    },
    "nullable": []
  },
  "hash": "e5d941be409182289791a9a0d9e7ad83342c2b641ab78b882f35ac7378469b9a"
}
